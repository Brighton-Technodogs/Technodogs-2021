// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands.drive;

import com.fasterxml.jackson.core.StreamReadFeature;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;

import frc.robot.Constants;
// import frc.robot.subsystems.DriveSubsystem;
import frc.robot.subsystems.DriveOdometrySubsystem;

/**
 *
 */
public class LimelightDriveOdometryCommand extends CommandBase {

  private final DriveOdometrySubsystem mDriveSubsystem;

  XboxController m_driverController = new XboxController(Constants.DriverControl.driverControllerPort);

  NetworkTable limelightTable = NetworkTableInstance.getDefault().getTable("limelight");

  NetworkTableEntry horizontalEntry;
  double horizontal;

  boolean fieldRelative = false;
  boolean previousButton = false;
  boolean currentButton = false;

  Timer limeTime = new Timer(); // it is lime time once again, my friends

  public LimelightDriveOdometryCommand(DriveOdometrySubsystem driveSubsystem) {
    // System.out.println("Constructing DriveCommand");
    this.mDriveSubsystem = driveSubsystem;
    this.addRequirements(driveSubsystem);

  }

  // Called just before this Command runs the first time
  @Override
  public void initialize() {
    // System.out.println("Initializing DriveCommand");
    // this.mDriveSubsystem.init();
    // this.mDriveSubsystem.enable();
    // boolean fieldRelative = false;
  }

  // Lidar lidarCrab = new Lidar(new DigitalInput(10));

  // Called repeatedly when this Command is scheduled to run
  @Override
  public void execute() {
    //nice
    double directionX = -m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftStickXAxis);
    double directionY = m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftStickYAxis);
    double rotation = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis);
    boolean slowMode = m_driverController.getBumper(Hand.kLeft);

    previousButton = currentButton;
    currentButton = m_driverController.getStartButton();

    if (currentButton && !previousButton) {
      fieldRelative = fieldRelative ? false : true;
    }

    if (m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightTriggerAxis) > 0.2) {
      // limelightTable.getEntry("ledMode").forceSetNumber(1); // set Limelight LED
      // Mode to OFF

      //SmartDashboard.putNumber("LimeLight Timer", limeTime.get()); // send the current value of the limelight timer to the dashboard
      if (limeTime.get() == 0) {
        System.out.println("Starting Limelight Timer and turning LED On");
        limeTime.start(); // start the limelight LED timer
        limelightTable.getEntry("ledMode").forceSetNumber(3); // set Limelight LED Mode to ON
      } else if (limeTime.get() >= 5.75 && limelightTable.getEntry("ledMode").getDouble(0) == 1) { // if timer is over 5.75 and LED is off
        System.out.println("Limelight timer has reached 5.75 seconds and will now reset");
        limeTime.stop(); // stop the limelight timer
        limeTime.reset(); // reset the limelight timer to 0
      } else if (limeTime.get() >= 5 && limelightTable.getEntry("ledMode").getDouble(0) == 3) { // if timer is over 5 seconds and LED is on
        System.out.println("Limelight timer has reached 5 seconds and the LED will turn off");
        limelightTable.getEntry("ledMode").forceSetNumber(1); // Set the LED to off
      } else if (limeTime.get() < 5 && limelightTable.getEntry("ledMode").getDouble(0) == 1) // if timer is less than 5 and LED is off
      {
        System.out.println("Limelight timer is under 5 seconds, turning the LED on");
        limelightTable.getEntry("ledMode").forceSetNumber(3); // Set the LED to ON
      }

      // find the center of target
      horizontalEntry = limelightTable.getEntry("tx");
      horizontal = horizontalEntry.getDouble(0);
      horizontal = horizontal - 2.9/* + limelightTable.getEntry("thor").getDouble(0) / 15 */;

      rotation = horizontal / 23.0;
      rotation = rotation - rotation * 0.55;
      if (rotation > 0.2 && limelightTable.getEntry("ledMode").getDouble(0) == 3) // only rotate if LED is on
      {
        rotation = -0.5;
        SmartDashboard.putBoolean("Drive Aligned", false); // Dashboard drive align off
      }
      else if (rotation < -0.2 && limelightTable.getEntry("ledMode").getDouble(0) == 3) // only rotate if LED is on
      {
        rotation = 0.5;
        SmartDashboard.putBoolean("Drive Aligned", false); // Dashboard drive align off
      }
      
      if (Math.abs(rotation) <= 0.015 && limelightTable.getEntry("ledMode").getDouble(0) == 3) // stop rotation and tell dashboard that the robot is aligned
      {
        // this will be run when once the robot has aligned it self with the target
        rotation = 0;
        SmartDashboard.putBoolean("Drive Aligned", true); // Dashboard drive align on
      }
      else if (Math.abs(rotation) <= 0.015 || limelightTable.getEntry("ledMode").getDouble(0) == 1) // pause rotation if robot is aligned, or the LED is off
      {
        // this will be run when once the robot has aligned it self with the target
        System.out.println("Pausing rotation alignment while LED is off...");
        rotation = 0;
        SmartDashboard.putBoolean("Drive Aligned", false); // Dashboard drive align on
      }

      // Not needed from Jacob T. Save for later if desired
      // if
      // (operatorController.getRawAxis(Constants.OperatorControl.operatorRightTrigger)
      // > 0.2)
      // {
      // rotation = 0;
      // }

      double controllerAssist = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis) / 15;

      // spin to center on target

      if (m_driverController.getXButton()) {
        // mDriveSubsystem.xMode();
      } else if (m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftTriggerAxis) > 0.2) {
        mDriveSubsystem.drive(0, 0, -controllerAssist * 1.5, false);
      } else {
        mDriveSubsystem.drive(0, 0, -rotation - controllerAssist, false);
      }
    } else {

      if (limelightTable.getEntry("ledMode").getDouble(0) == 3 || limeTime.get() >= 5) // If limelight led is set on or timer is greater than 5
      {
        // ^^^^^^^^^ the limeTime.get() >=5 makes the timer reset when targeting mode is
        // exited between 5 and 5.75 seconds
        limeTime.stop();
        limeTime.reset();
        limelightTable.getEntry("ledMode").forceSetDouble(1);
        SmartDashboard.putBoolean("Drive Aligned", false); // Shuffleboard drive align off
        SmartDashboard.putNumber("LimeLight Timer", 0); // set the limelight timer to 0 when exiting alignment sequence
        System.out.println("Targeting Mode Exited, turning LED off");
      }

      rotation = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis);

      // SmartDashboard.putNumber("X Box X-Axis", directionX);
      // SmartDashboard.putNumber("X Box Y-Axis", directionY);
      // SmartDashboard.putNumber("X Box Rotation", rotation);

      // drive normally with joysticks
      // this.mDriveSubsystem.drive(directionX, directionY, rotation, false, true,
      // false);
      if (slowMode) {
        this.mDriveSubsystem.drive(directionX / 2, directionY / 2, rotation / 2, fieldRelative);
      } else {
        this.mDriveSubsystem.drive(directionX, directionY, rotation, fieldRelative);
      }
    }

    // Robot.driveSubsystem.drive(-Robot.oi.driverController.getLeftStickXValue(),
    // -Robot.oi.driverController.getLeftStickYValue(),
    // -Robot.oi.driverController.getRightStickXValue(), false,
    // Robot.oi.driverController.getRightBumperPressed(),
    // Robot.oi.driverController.getXButtonPressed());
  }

}
