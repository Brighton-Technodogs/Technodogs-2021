// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands.drive;

import com.fasterxml.jackson.core.StreamReadFeature;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;

import frc.robot.Constants;
// import frc.robot.subsystems.DriveSubsystem;
import frc.robot.subsystems.DriveOdometrySubsystem;

/**
 *
 */
public class LimelightDriveOdometryCommand extends CommandBase {

  private final DriveOdometrySubsystem mDriveSubsystem;

  XboxController m_driverController = new XboxController(Constants.DriverControl.driverControllerPort);
  XboxController m_operatorController = new XboxController(Constants.OperatorControl.operatorControllerPort);

  NetworkTable limelightTable = NetworkTableInstance.getDefault().getTable("limelight");

  NetworkTableEntry horizontalEntry;
  double horizontal;

  boolean fieldRelative = false;
  boolean previousButton = false;
  boolean currentButton = false;
  Timer zeroTime = new Timer();

  public LimelightDriveOdometryCommand(DriveOdometrySubsystem driveSubsystem) {
    // System.out.println("Constructing DriveCommand");
    this.mDriveSubsystem = driveSubsystem;
    this.addRequirements(driveSubsystem);

  }

  // Called just before this Command runs the first time
  @Override
  public void initialize() {
    // System.out.println("Initializing DriveCommand");
    // this.mDriveSubsystem.init();
    // this.mDriveSubsystem.enable();
    // boolean fieldRelative = false;
  }

  // Called repeatedly when this Command is scheduled to run
  @Override
  public void execute() {
    double directionX = -m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftStickXAxis);
    double directionY = m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftStickYAxis);
    double rotation = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis);
    boolean slowMode = m_driverController.getBumper(Hand.kLeft);

    // makes start button toggle fieldOriented boolean
    previousButton = currentButton;
    currentButton = m_driverController.getStartButton();
    if (currentButton && !previousButton) {
      fieldRelative = fieldRelative ? false : true;
    }

    // back button to reset heading for field oriented mode
    if (m_driverController.getBackButton()) {
      zeroTime.start();
    } else {
      zeroTime.stop();
    }

    if  (zeroTime.get() >= 1) {
      this.mDriveSubsystem.zeroFO();
    }

    if (m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightTriggerAxis) > 0.2) {
      limelightTable.getEntry("ledMode").setNumber(3); // set Limelight LED

      // find the center of target
      horizontalEntry = limelightTable.getEntry("tx");
      horizontal = horizontalEntry.getDouble(0);
      horizontal = horizontal - 2.9/* + limelightTable.getEntry("thor").getDouble(0) / 15 */;

      rotation = horizontal / 23.0;
      rotation = rotation - rotation * 0.55;
      if (rotation > 0.2)
      {
        rotation = -0.5;
        mDriveSubsystem.unsetAligned();
        m_operatorController.setRumble(RumbleType.kRightRumble, 0);
        m_operatorController.setRumble(RumbleType.kLeftRumble, 0);
      }
      else if (rotation < -0.2)
      {
        rotation = 0.5;
        mDriveSubsystem.unsetAligned();
        m_operatorController.setRumble(RumbleType.kRightRumble, 0);
        m_operatorController.setRumble(RumbleType.kLeftRumble, 0);
      }
      
      if (Math.abs(rotation) <= 0.015) // stop rotation and tell dashboard that the robot is aligned
      {
        // this will be run when once the robot has aligned it self with the target
        rotation = 0;
        mDriveSubsystem.setAligned();
        m_operatorController.setRumble(RumbleType.kRightRumble, 0.5);
        m_operatorController.setRumble(RumbleType.kLeftRumble, 0.5);
      }

      // Not needed from Jacob T. Save for later if desired
      // if
      // (operatorController.getRawAxis(Constants.OperatorControl.operatorRightTrigger)
      // > 0.2)
      // {
      // rotation = 0;
      // }

      double controllerAssist = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis) / 15;

      // spin to center on target

      if (m_driverController.getXButton()) {
        // mDriveSubsystem.xMode();
      } else if (m_driverController.getRawAxis(Constants.DriverControl.driverControllerLeftTriggerAxis) > 0.2) {
        mDriveSubsystem.drive(0, 0, -controllerAssist * 1.5, false);
      } else {
        mDriveSubsystem.drive(0, 0, -rotation - controllerAssist, false);
      }
    } else {

      if (limelightTable.getEntry("ledMode").getDouble(0) == 3) // If limelight led is set on or timer is greater than 5
      {
        limelightTable.getEntry("ledMode").setDouble(1);
        mDriveSubsystem.unsetAligned();
        m_operatorController.setRumble(RumbleType.kRightRumble, 0);
        m_operatorController.setRumble(RumbleType.kLeftRumble, 0);
      }

      rotation = m_driverController.getRawAxis(Constants.DriverControl.driverControllerRightStickXAxis);

      // drive normally with joysticks
      if (slowMode) {
        this.mDriveSubsystem.drive(directionX / 2, directionY / 2, rotation / 2, fieldRelative);
      } else {
        this.mDriveSubsystem.drive(directionX, directionY, rotation, fieldRelative);
      }
    }
  }

}
